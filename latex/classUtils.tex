\hypertarget{classUtils}{}\section{Utils Class Reference}
\label{classUtils}\index{Utils@{Utils}}


Auxiliary class that contains useful methods from the main class.  


\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classUtils_a452e78692c87ed5c7c993b6c6ac4981a}{Utils} ()
\begin{DoxyCompactList}\small\item\em identifier of the genomic record in the output mpegg format \end{DoxyCompactList}\item 
\hyperlink{classUtils_afa5e70facffc286607498e7edb639b8a}{$\sim$\+Utils} ()
\begin{DoxyCompactList}\small\item\em Destructor method. \end{DoxyCompactList}\item 
std\+::string \hyperlink{classUtils_a612bb61872bc69a806c0159dcd3da28c}{get\+Extended\+Cigar} (Bam\+Alignment\+Record \&record)
\begin{DoxyCompactList}\small\item\em Gets the extended cigar of the read. \end{DoxyCompactList}\item 
Bam\+Alignment\+Record \hyperlink{classUtils_acba7464c0972dceade69f1f1aef4e5f4}{get\+Second\+Record} (Bam\+Alignment\+Record \&record)
\begin{DoxyCompactList}\small\item\em Get the second read for the read pair. \end{DoxyCompactList}\item 
void \hyperlink{classUtils_a6e24ee791d9ce74a9e8991c8bf7cecdf}{update\+Record} (Bam\+Alignment\+Record \&record, int \&pos)
\begin{DoxyCompactList}\small\item\em Updates the second read from the pair with a new value. \end{DoxyCompactList}\item 
bool \hyperlink{classUtils_ab384d430e1cc5e0cc1ce1913eeab7e82}{is\+ClassP} (Bam\+Alignment\+Record \&record)
\begin{DoxyCompactList}\small\item\em To determine if the read belongs to class P, reads perfectly matching the reference sequence. \end{DoxyCompactList}\item 
bool \hyperlink{classUtils_a68dc1efdf9895d4c63a0a78a09d407d4}{is\+ClassN} (Bam\+Alignment\+Record \&record)
\begin{DoxyCompactList}\small\item\em To determine if the read belongs to class N, reads containing mismatches which are unknonwn bases only. \end{DoxyCompactList}\item 
bool \hyperlink{classUtils_a2ab4c3d1059e841aaa81bf6eb7650c46}{is\+ClassM} (Bam\+Alignment\+Record \&record)
\begin{DoxyCompactList}\small\item\em To determine if the read belongs to class M, reads contanining at least one substitution, optionally unknown bases and no insertion, deletions and clipped bases. \end{DoxyCompactList}\item 
bool \hyperlink{classUtils_a4e19b89b708e23964398b1e561686423}{is\+ClassI} (Bam\+Alignment\+Record \&record)
\begin{DoxyCompactList}\small\item\em To determine if the read belongs to class I, reads contanining at least one insertion, deletion or clippled base, and optionally unknown bases or substitution. \end{DoxyCompactList}\item 
bool \hyperlink{classUtils_abf817f51550147aa6f7265e45c357f14}{is\+Class\+HM} (Bam\+Alignment\+Record \&record)
\begin{DoxyCompactList}\small\item\em To determine if the read belongs to class HM, reads where only one read is mapped. \end{DoxyCompactList}\item 
bool \hyperlink{classUtils_a19d7def56cdd52bfca9e4f2a3f6ac535}{is\+ClassU} (Bam\+Alignment\+Record \&record)
\begin{DoxyCompactList}\small\item\em To determine if the read belongs to class U, unmapped reads only. \end{DoxyCompactList}\item 
uint8\+\_\+t \hyperlink{classUtils_a75b0e41bc884a3fcebb4f55c45855d82}{get\+Class\+Type} (Bam\+Alignment\+Record \&record)
\begin{DoxyCompactList}\small\item\em To determine the data class where a read belongs to. \end{DoxyCompactList}\item 
int \hyperlink{classUtils_a5e6b1fddcaa2740687c8c787e8d1e9cb}{get\+N\+Mtag} (Bam\+Alignment\+Record \&record)
\begin{DoxyCompactList}\small\item\em Extracts the value of the NM tag from the read. \end{DoxyCompactList}\item 
void \hyperlink{classUtils_a5a62399a8bb675cc0d41846a2e38cfc5}{convert\+To\+Mpegg\+Record} (\hyperlink{structMpeggRecord}{Mpegg\+Record} \&result, Bam\+Alignment\+Record \&record)
\begin{DoxyCompactList}\small\item\em Converts the read or paired read to the mpegg output format. \end{DoxyCompactList}\item 
std\+::vector$<$ std\+::pair$<$ uint16\+\_\+t, std\+::string $>$ $>$ \hyperlink{classUtils_ad8cf76e464dc733abda80738709740e5}{get\+Mmpos\+Value} (Bam\+Alignment\+Record \&record)
\begin{DoxyCompactList}\small\item\em Writes the mmpos descriptor value to the respective file according to the class type. \end{DoxyCompactList}\item 
std\+::string \hyperlink{classUtils_acbd0c6160115aea411d926e4c66fdb2d}{int32\+\_\+to\+\_\+hex} (int32\+\_\+t value)
\begin{DoxyCompactList}\small\item\em A simple function that converts a value from a int to a hex. \end{DoxyCompactList}\item 
void \hyperlink{classUtils_abddd37adce88799fc8a66f7779c407bb}{remove\+First\+Read} ()
\begin{DoxyCompactList}\small\item\em Removes the first read from the list of paired reads. \end{DoxyCompactList}\item 
void \hyperlink{classUtils_a23ce2e6de05c4574f2296353f03fc9db}{get\+Allreads} (std\+::multimap$<$ int, std\+::pair$<$ Bam\+Alignment\+Record, Bam\+Alignment\+Record $>$ $>$ \&all\+Reads)
\begin{DoxyCompactList}\small\item\em Gets all the paired reads. \end{DoxyCompactList}\item 
void \hyperlink{classUtils_a20d62b8e6495536108e7bfe1b955355a}{insert\+Access\+Unit} (\hyperlink{classAccessUnit}{Access\+Unit} au)
\begin{DoxyCompactList}\small\item\em Inserts a new access unit to the list of access units. \end{DoxyCompactList}\item 
void \hyperlink{classUtils_a1f13b160cd02b1fdf44e6ff8ba2c2406}{get\+All\+Access\+Units} (std\+::vector$<$ \hyperlink{classAccessUnit}{Access\+Unit} $>$ \&au)
\begin{DoxyCompactList}\small\item\em Gets all the access units stored. \end{DoxyCompactList}\item 
void \hyperlink{classUtils_aa2bffe3dfec78617ebdf207ff0fa0820}{insert\+Read} (Bam\+Alignment\+Record first, Bam\+Alignment\+Record second)
\begin{DoxyCompactList}\small\item\em Inserts a new read pair to the list of paired reads. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static std\+::string \hyperlink{classUtils_a61182e6d5c700eedfaff392b51826af3}{get\+Cigar} (String$<$ Cigar\+Element$<$$>$ $>$ \&r\+Cigar)
\begin{DoxyCompactList}\small\item\em Convert from a string$<$cigar\+Element$>$ to a std\+::string. \end{DoxyCompactList}\item 
static uint16\+\_\+t {\bfseries reads\+\_\+distance} (Bam\+Alignment\+Record \&record)\hypertarget{classUtils_a02d521d4d7cecbe20acab176d08b7857}{}\label{classUtils_a02d521d4d7cecbe20acab176d08b7857}

\item 
static std\+::string \hyperlink{classUtils_a58dcdc1dd071936078799ee35d5f2502}{get\+M\+Dtag} (Bam\+Alignment\+Record \&record)
\begin{DoxyCompactList}\small\item\em Extracts the value of the MD tag from the read. \end{DoxyCompactList}\item 
static uint64\+\_\+t {\bfseries hex\+\_\+to\+\_\+int} (std\+::string value)\hypertarget{classUtils_aaccbd9f6e04b06c6c95617ec36709f96}{}\label{classUtils_aaccbd9f6e04b06c6c95617ec36709f96}

\item 
static std\+::string {\bfseries int16\+\_\+to\+\_\+hex} (int16\+\_\+t value)\hypertarget{classUtils_a1b2c28fa49f1048d6af6f8b768490df6}{}\label{classUtils_a1b2c28fa49f1048d6af6f8b768490df6}

\end{DoxyCompactItemize}


\subsection{Detailed Description}
Auxiliary class that contains useful methods from the main class. 

\begin{DoxyAuthor}{Author}
Omair Iqbal
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
04/2018
\end{DoxyDate}
Contact\+: \href{mailto:Omair95@protonmail.com}{\tt Omair95@protonmail.\+com} 

\subsection{Constructor \& Destructor Documentation}
\index{Utils@{Utils}!Utils@{Utils}}
\index{Utils@{Utils}!Utils@{Utils}}
\subsubsection[{\texorpdfstring{Utils()}{Utils()}}]{\setlength{\rightskip}{0pt plus 5cm}Utils\+::\+Utils (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classUtils_a452e78692c87ed5c7c993b6c6ac4981a}{}\label{classUtils_a452e78692c87ed5c7c993b6c6ac4981a}


identifier of the genomic record in the output mpegg format 

Constructor method 
\begin{DoxyParams}{Parameters}
{\em void} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
void 
\end{DoxyReturn}
\index{Utils@{Utils}!````~Utils@{$\sim$\+Utils}}
\index{````~Utils@{$\sim$\+Utils}!Utils@{Utils}}
\subsubsection[{\texorpdfstring{$\sim$\+Utils()}{~Utils()}}]{\setlength{\rightskip}{0pt plus 5cm}Utils\+::$\sim$\+Utils (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classUtils_afa5e70facffc286607498e7edb639b8a}{}\label{classUtils_afa5e70facffc286607498e7edb639b8a}


Destructor method. 


\begin{DoxyParams}{Parameters}
{\em void} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
void 
\end{DoxyReturn}


\subsection{Member Function Documentation}
\index{Utils@{Utils}!convert\+To\+Mpegg\+Record@{convert\+To\+Mpegg\+Record}}
\index{convert\+To\+Mpegg\+Record@{convert\+To\+Mpegg\+Record}!Utils@{Utils}}
\subsubsection[{\texorpdfstring{convert\+To\+Mpegg\+Record(\+Mpegg\+Record \&result, Bam\+Alignment\+Record \&record)}{convertToMpeggRecord(MpeggRecord &result, BamAlignmentRecord &record)}}]{\setlength{\rightskip}{0pt plus 5cm}void Utils\+::convert\+To\+Mpegg\+Record (
\begin{DoxyParamCaption}
\item[{{\bf Mpegg\+Record} \&}]{result, }
\item[{Bam\+Alignment\+Record \&}]{record}
\end{DoxyParamCaption}
)}\hypertarget{classUtils_a5a62399a8bb675cc0d41846a2e38cfc5}{}\label{classUtils_a5a62399a8bb675cc0d41846a2e38cfc5}


Converts the read or paired read to the mpegg output format. 


\begin{DoxyParams}{Parameters}
{\em record} & first read from the pair \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
void 
\end{DoxyReturn}
\index{Utils@{Utils}!get\+All\+Access\+Units@{get\+All\+Access\+Units}}
\index{get\+All\+Access\+Units@{get\+All\+Access\+Units}!Utils@{Utils}}
\subsubsection[{\texorpdfstring{get\+All\+Access\+Units(std\+::vector$<$ Access\+Unit $>$ \&au)}{getAllAccessUnits(std::vector< AccessUnit > &au)}}]{\setlength{\rightskip}{0pt plus 5cm}void Utils\+::get\+All\+Access\+Units (
\begin{DoxyParamCaption}
\item[{std\+::vector$<$ {\bf Access\+Unit} $>$ \&}]{au}
\end{DoxyParamCaption}
)}\hypertarget{classUtils_a1f13b160cd02b1fdf44e6ff8ba2c2406}{}\label{classUtils_a1f13b160cd02b1fdf44e6ff8ba2c2406}


Gets all the access units stored. 


\begin{DoxyParams}{Parameters}
{\em au} & will contain the value of all access units \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
void 
\end{DoxyReturn}
\index{Utils@{Utils}!get\+Allreads@{get\+Allreads}}
\index{get\+Allreads@{get\+Allreads}!Utils@{Utils}}
\subsubsection[{\texorpdfstring{get\+Allreads(std\+::multimap$<$ int, std\+::pair$<$ Bam\+Alignment\+Record, Bam\+Alignment\+Record $>$ $>$ \&all\+Reads)}{getAllreads(std::multimap< int, std::pair< BamAlignmentRecord, BamAlignmentRecord > > &allReads)}}]{\setlength{\rightskip}{0pt plus 5cm}void Utils\+::get\+Allreads (
\begin{DoxyParamCaption}
\item[{std\+::multimap$<$ int, std\+::pair$<$ Bam\+Alignment\+Record, Bam\+Alignment\+Record $>$ $>$ \&}]{all\+Reads}
\end{DoxyParamCaption}
)}\hypertarget{classUtils_a23ce2e6de05c4574f2296353f03fc9db}{}\label{classUtils_a23ce2e6de05c4574f2296353f03fc9db}


Gets all the paired reads. 


\begin{DoxyParams}{Parameters}
{\em all\+Reads} & will contain the value of the paired readss \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
void 
\end{DoxyReturn}
\index{Utils@{Utils}!get\+Cigar@{get\+Cigar}}
\index{get\+Cigar@{get\+Cigar}!Utils@{Utils}}
\subsubsection[{\texorpdfstring{get\+Cigar(\+String$<$ Cigar\+Element$<$$>$ $>$ \&r\+Cigar)}{getCigar(String< CigarElement<> > &rCigar)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string Utils\+::get\+Cigar (
\begin{DoxyParamCaption}
\item[{String$<$ Cigar\+Element$<$$>$ $>$ \&}]{r\+Cigar}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classUtils_a61182e6d5c700eedfaff392b51826af3}{}\label{classUtils_a61182e6d5c700eedfaff392b51826af3}


Convert from a string$<$cigar\+Element$>$ to a std\+::string. 


\begin{DoxyParams}{Parameters}
{\em r\+Cigar} & value to be converted \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
converted value 
\end{DoxyReturn}
\index{Utils@{Utils}!get\+Class\+Type@{get\+Class\+Type}}
\index{get\+Class\+Type@{get\+Class\+Type}!Utils@{Utils}}
\subsubsection[{\texorpdfstring{get\+Class\+Type(\+Bam\+Alignment\+Record \&record)}{getClassType(BamAlignmentRecord &record)}}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t Utils\+::get\+Class\+Type (
\begin{DoxyParamCaption}
\item[{Bam\+Alignment\+Record \&}]{record}
\end{DoxyParamCaption}
)}\hypertarget{classUtils_a75b0e41bc884a3fcebb4f55c45855d82}{}\label{classUtils_a75b0e41bc884a3fcebb4f55c45855d82}


To determine the data class where a read belongs to. 


\begin{DoxyParams}{Parameters}
{\em record} & is the first read from the pair \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
integer indicating the type of data class of the read 
\end{DoxyReturn}
\index{Utils@{Utils}!get\+Extended\+Cigar@{get\+Extended\+Cigar}}
\index{get\+Extended\+Cigar@{get\+Extended\+Cigar}!Utils@{Utils}}
\subsubsection[{\texorpdfstring{get\+Extended\+Cigar(\+Bam\+Alignment\+Record \&record)}{getExtendedCigar(BamAlignmentRecord &record)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string Utils\+::get\+Extended\+Cigar (
\begin{DoxyParamCaption}
\item[{Bam\+Alignment\+Record \&}]{record}
\end{DoxyParamCaption}
)}\hypertarget{classUtils_a612bb61872bc69a806c0159dcd3da28c}{}\label{classUtils_a612bb61872bc69a806c0159dcd3da28c}


Gets the extended cigar of the read. 


\begin{DoxyParams}{Parameters}
{\em record} & read to be treated \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Extended cigar of the read 
\end{DoxyReturn}
\index{Utils@{Utils}!get\+M\+Dtag@{get\+M\+Dtag}}
\index{get\+M\+Dtag@{get\+M\+Dtag}!Utils@{Utils}}
\subsubsection[{\texorpdfstring{get\+M\+Dtag(\+Bam\+Alignment\+Record \&record)}{getMDtag(BamAlignmentRecord &record)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string Utils\+::get\+M\+Dtag (
\begin{DoxyParamCaption}
\item[{Bam\+Alignment\+Record \&}]{record}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{classUtils_a58dcdc1dd071936078799ee35d5f2502}{}\label{classUtils_a58dcdc1dd071936078799ee35d5f2502}


Extracts the value of the MD tag from the read. 


\begin{DoxyParams}{Parameters}
{\em record} & read to be treated \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
string containing the value of the MD tag 
\end{DoxyReturn}
\index{Utils@{Utils}!get\+Mmpos\+Value@{get\+Mmpos\+Value}}
\index{get\+Mmpos\+Value@{get\+Mmpos\+Value}!Utils@{Utils}}
\subsubsection[{\texorpdfstring{get\+Mmpos\+Value(\+Bam\+Alignment\+Record \&record)}{getMmposValue(BamAlignmentRecord &record)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::vector$<$ std\+::pair$<$ uint16\+\_\+t, std\+::string $>$ $>$ Utils\+::get\+Mmpos\+Value (
\begin{DoxyParamCaption}
\item[{Bam\+Alignment\+Record \&}]{record}
\end{DoxyParamCaption}
)}\hypertarget{classUtils_ad8cf76e464dc733abda80738709740e5}{}\label{classUtils_ad8cf76e464dc733abda80738709740e5}


Writes the mmpos descriptor value to the respective file according to the class type. 


\begin{DoxyParams}{Parameters}
{\em value} & value of the mmpos descriptor \\
\hline
{\em class\+Type} & class type \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
void 
\end{DoxyReturn}
\index{Utils@{Utils}!get\+N\+Mtag@{get\+N\+Mtag}}
\index{get\+N\+Mtag@{get\+N\+Mtag}!Utils@{Utils}}
\subsubsection[{\texorpdfstring{get\+N\+Mtag(\+Bam\+Alignment\+Record \&record)}{getNMtag(BamAlignmentRecord &record)}}]{\setlength{\rightskip}{0pt plus 5cm}int Utils\+::get\+N\+Mtag (
\begin{DoxyParamCaption}
\item[{Bam\+Alignment\+Record \&}]{record}
\end{DoxyParamCaption}
)}\hypertarget{classUtils_a5e6b1fddcaa2740687c8c787e8d1e9cb}{}\label{classUtils_a5e6b1fddcaa2740687c8c787e8d1e9cb}


Extracts the value of the NM tag from the read. 


\begin{DoxyParams}{Parameters}
{\em record} & read to be treated \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
integer containing the value of the NM tag 
\end{DoxyReturn}
\index{Utils@{Utils}!get\+Second\+Record@{get\+Second\+Record}}
\index{get\+Second\+Record@{get\+Second\+Record}!Utils@{Utils}}
\subsubsection[{\texorpdfstring{get\+Second\+Record(\+Bam\+Alignment\+Record \&record)}{getSecondRecord(BamAlignmentRecord &record)}}]{\setlength{\rightskip}{0pt plus 5cm}Bam\+Alignment\+Record Utils\+::get\+Second\+Record (
\begin{DoxyParamCaption}
\item[{Bam\+Alignment\+Record \&}]{record}
\end{DoxyParamCaption}
)}\hypertarget{classUtils_acba7464c0972dceade69f1f1aef4e5f4}{}\label{classUtils_acba7464c0972dceade69f1f1aef4e5f4}


Get the second read for the read pair. 


\begin{DoxyParams}{Parameters}
{\em record} & first read from the the pair \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
second read of the pair 
\end{DoxyReturn}
\index{Utils@{Utils}!insert\+Access\+Unit@{insert\+Access\+Unit}}
\index{insert\+Access\+Unit@{insert\+Access\+Unit}!Utils@{Utils}}
\subsubsection[{\texorpdfstring{insert\+Access\+Unit(\+Access\+Unit au)}{insertAccessUnit(AccessUnit au)}}]{\setlength{\rightskip}{0pt plus 5cm}void Utils\+::insert\+Access\+Unit (
\begin{DoxyParamCaption}
\item[{{\bf Access\+Unit}}]{au}
\end{DoxyParamCaption}
)}\hypertarget{classUtils_a20d62b8e6495536108e7bfe1b955355a}{}\label{classUtils_a20d62b8e6495536108e7bfe1b955355a}


Inserts a new access unit to the list of access units. 


\begin{DoxyParams}{Parameters}
{\em au} & access unit of any kind \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
void 
\end{DoxyReturn}
\index{Utils@{Utils}!insert\+Read@{insert\+Read}}
\index{insert\+Read@{insert\+Read}!Utils@{Utils}}
\subsubsection[{\texorpdfstring{insert\+Read(\+Bam\+Alignment\+Record first, Bam\+Alignment\+Record second)}{insertRead(BamAlignmentRecord first, BamAlignmentRecord second)}}]{\setlength{\rightskip}{0pt plus 5cm}void Utils\+::insert\+Read (
\begin{DoxyParamCaption}
\item[{Bam\+Alignment\+Record}]{first, }
\item[{Bam\+Alignment\+Record}]{second}
\end{DoxyParamCaption}
)}\hypertarget{classUtils_aa2bffe3dfec78617ebdf207ff0fa0820}{}\label{classUtils_aa2bffe3dfec78617ebdf207ff0fa0820}


Inserts a new read pair to the list of paired reads. 


\begin{DoxyParams}{Parameters}
{\em first} & first read from the pair \\
\hline
{\em second} & second read from the pair \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
void 
\end{DoxyReturn}
\index{Utils@{Utils}!int32\+\_\+to\+\_\+hex@{int32\+\_\+to\+\_\+hex}}
\index{int32\+\_\+to\+\_\+hex@{int32\+\_\+to\+\_\+hex}!Utils@{Utils}}
\subsubsection[{\texorpdfstring{int32\+\_\+to\+\_\+hex(int32\+\_\+t value)}{int32_to_hex(int32_t value)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string Utils\+::int32\+\_\+to\+\_\+hex (
\begin{DoxyParamCaption}
\item[{int32\+\_\+t}]{value}
\end{DoxyParamCaption}
)}\hypertarget{classUtils_acbd0c6160115aea411d926e4c66fdb2d}{}\label{classUtils_acbd0c6160115aea411d926e4c66fdb2d}


A simple function that converts a value from a int to a hex. 


\begin{DoxyParams}{Parameters}
{\em value} & int value to be converted \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
hexadecimal value converted 
\end{DoxyReturn}
\index{Utils@{Utils}!is\+Class\+HM@{is\+Class\+HM}}
\index{is\+Class\+HM@{is\+Class\+HM}!Utils@{Utils}}
\subsubsection[{\texorpdfstring{is\+Class\+H\+M(\+Bam\+Alignment\+Record \&record)}{isClassHM(BamAlignmentRecord &record)}}]{\setlength{\rightskip}{0pt plus 5cm}bool Utils\+::is\+Class\+HM (
\begin{DoxyParamCaption}
\item[{Bam\+Alignment\+Record \&}]{record}
\end{DoxyParamCaption}
)}\hypertarget{classUtils_abf817f51550147aa6f7265e45c357f14}{}\label{classUtils_abf817f51550147aa6f7265e45c357f14}


To determine if the read belongs to class HM, reads where only one read is mapped. 


\begin{DoxyParams}{Parameters}
{\em record} & is the first read from the pair \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
bool indicating if the read belongs to class HM 
\end{DoxyReturn}
\index{Utils@{Utils}!is\+ClassI@{is\+ClassI}}
\index{is\+ClassI@{is\+ClassI}!Utils@{Utils}}
\subsubsection[{\texorpdfstring{is\+Class\+I(\+Bam\+Alignment\+Record \&record)}{isClassI(BamAlignmentRecord &record)}}]{\setlength{\rightskip}{0pt plus 5cm}bool Utils\+::is\+ClassI (
\begin{DoxyParamCaption}
\item[{Bam\+Alignment\+Record \&}]{record}
\end{DoxyParamCaption}
)}\hypertarget{classUtils_a4e19b89b708e23964398b1e561686423}{}\label{classUtils_a4e19b89b708e23964398b1e561686423}


To determine if the read belongs to class I, reads contanining at least one insertion, deletion or clippled base, and optionally unknown bases or substitution. 


\begin{DoxyParams}{Parameters}
{\em record} & is the first read from the pair \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
bool indicating if the read belongs to class I 
\end{DoxyReturn}
\index{Utils@{Utils}!is\+ClassM@{is\+ClassM}}
\index{is\+ClassM@{is\+ClassM}!Utils@{Utils}}
\subsubsection[{\texorpdfstring{is\+Class\+M(\+Bam\+Alignment\+Record \&record)}{isClassM(BamAlignmentRecord &record)}}]{\setlength{\rightskip}{0pt plus 5cm}bool Utils\+::is\+ClassM (
\begin{DoxyParamCaption}
\item[{Bam\+Alignment\+Record \&}]{record}
\end{DoxyParamCaption}
)}\hypertarget{classUtils_a2ab4c3d1059e841aaa81bf6eb7650c46}{}\label{classUtils_a2ab4c3d1059e841aaa81bf6eb7650c46}


To determine if the read belongs to class M, reads contanining at least one substitution, optionally unknown bases and no insertion, deletions and clipped bases. 


\begin{DoxyParams}{Parameters}
{\em record} & first read from the pair \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
bool indicating if the read belongs to class M 
\end{DoxyReturn}
\index{Utils@{Utils}!is\+ClassN@{is\+ClassN}}
\index{is\+ClassN@{is\+ClassN}!Utils@{Utils}}
\subsubsection[{\texorpdfstring{is\+Class\+N(\+Bam\+Alignment\+Record \&record)}{isClassN(BamAlignmentRecord &record)}}]{\setlength{\rightskip}{0pt plus 5cm}bool Utils\+::is\+ClassN (
\begin{DoxyParamCaption}
\item[{Bam\+Alignment\+Record \&}]{record}
\end{DoxyParamCaption}
)}\hypertarget{classUtils_a68dc1efdf9895d4c63a0a78a09d407d4}{}\label{classUtils_a68dc1efdf9895d4c63a0a78a09d407d4}


To determine if the read belongs to class N, reads containing mismatches which are unknonwn bases only. 


\begin{DoxyParams}{Parameters}
{\em record} & first read from the pair \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
bool indicating if the read belongs to class N 
\end{DoxyReturn}
\index{Utils@{Utils}!is\+ClassP@{is\+ClassP}}
\index{is\+ClassP@{is\+ClassP}!Utils@{Utils}}
\subsubsection[{\texorpdfstring{is\+Class\+P(\+Bam\+Alignment\+Record \&record)}{isClassP(BamAlignmentRecord &record)}}]{\setlength{\rightskip}{0pt plus 5cm}bool Utils\+::is\+ClassP (
\begin{DoxyParamCaption}
\item[{Bam\+Alignment\+Record \&}]{record}
\end{DoxyParamCaption}
)}\hypertarget{classUtils_ab384d430e1cc5e0cc1ce1913eeab7e82}{}\label{classUtils_ab384d430e1cc5e0cc1ce1913eeab7e82}


To determine if the read belongs to class P, reads perfectly matching the reference sequence. 


\begin{DoxyParams}{Parameters}
{\em record} & first read of the pair \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
bool indicating if the read belongs to class P 
\end{DoxyReturn}
\index{Utils@{Utils}!is\+ClassU@{is\+ClassU}}
\index{is\+ClassU@{is\+ClassU}!Utils@{Utils}}
\subsubsection[{\texorpdfstring{is\+Class\+U(\+Bam\+Alignment\+Record \&record)}{isClassU(BamAlignmentRecord &record)}}]{\setlength{\rightskip}{0pt plus 5cm}bool Utils\+::is\+ClassU (
\begin{DoxyParamCaption}
\item[{Bam\+Alignment\+Record \&}]{record}
\end{DoxyParamCaption}
)}\hypertarget{classUtils_a19d7def56cdd52bfca9e4f2a3f6ac535}{}\label{classUtils_a19d7def56cdd52bfca9e4f2a3f6ac535}


To determine if the read belongs to class U, unmapped reads only. 


\begin{DoxyParams}{Parameters}
{\em record} & is the first read from the pair \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
bool indicating if the read belongs to class U 
\end{DoxyReturn}
\index{Utils@{Utils}!remove\+First\+Read@{remove\+First\+Read}}
\index{remove\+First\+Read@{remove\+First\+Read}!Utils@{Utils}}
\subsubsection[{\texorpdfstring{remove\+First\+Read()}{removeFirstRead()}}]{\setlength{\rightskip}{0pt plus 5cm}void Utils\+::remove\+First\+Read (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classUtils_abddd37adce88799fc8a66f7779c407bb}{}\label{classUtils_abddd37adce88799fc8a66f7779c407bb}


Removes the first read from the list of paired reads. 


\begin{DoxyParams}{Parameters}
{\em void} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
void 
\end{DoxyReturn}
\index{Utils@{Utils}!update\+Record@{update\+Record}}
\index{update\+Record@{update\+Record}!Utils@{Utils}}
\subsubsection[{\texorpdfstring{update\+Record(\+Bam\+Alignment\+Record \&record, int \&pos)}{updateRecord(BamAlignmentRecord &record, int &pos)}}]{\setlength{\rightskip}{0pt plus 5cm}void Utils\+::update\+Record (
\begin{DoxyParamCaption}
\item[{Bam\+Alignment\+Record \&}]{record, }
\item[{int \&}]{pos}
\end{DoxyParamCaption}
)}\hypertarget{classUtils_a6e24ee791d9ce74a9e8991c8bf7cecdf}{}\label{classUtils_a6e24ee791d9ce74a9e8991c8bf7cecdf}


Updates the second read from the pair with a new value. 


\begin{DoxyParams}{Parameters}
{\em record} & new value of the second pair \\
\hline
{\em pos} & position of the first read in the pair \\
\hline
\end{DoxyParams}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
\hyperlink{Utils_8h}{Utils.\+h}\item 
Utils.\+cpp\end{DoxyCompactItemize}
